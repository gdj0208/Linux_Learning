# 1️⃣ 시스템 호출과 라이브러리 함수

## 🎯 시스템 호출
`리턴값 = 시스템 호출명(인자);`
- 시스템 호출명은 함수명처럼 사용할 이름이 정의

<br>

## 🎯 라이브러리 함수
- 라이브러리 : 미리 컴파일된 함수를 묶어서 제공하는 특수한 형태의 파일
- 라이브러리 함수 : 라이브러리에 포함된 함수를 의미
- 리눅스 시스템에서 라이브러리는 보통 /urs/lib에 위치
- 정적 라이브러리는 프로그램을 컴파일할 때 같이 적재되어 실행파일을 구성
- 공유 라이브러리는 실행파일에 포함되지 않아 메모리를 효율적으로 사용하기 위해 사용

<br>

---

# 2️⃣ man 명령어

## 🎯 man 명령어란
man은 manual의 약자이다 

터미널에서 메뉴얼을 섹션별로 구분하여 설명한다. 
- 섹션 1 : 리눅스에서 사용하는 일반적인 명령에 대한 설명 
- 섹션 2 : 시스템 호출 
- 섹션 3 : 라이브러리 함수 

man 명령으로 검색하면 섹션 번호가 가장 낮은것이 기본으로 출력된다. 

man 명령의 결과를 출력하는 형식은 리눅스와 유닉스에서 차이가 있다. 
<br>

## 🎯 man 페이지
man 페이지란 개발자가 항상 옆에 두고 보는 "공식 설명서"라고 할 수 있겠다.

man 페이지를 구성하는 요소들로는 다음과 같다.
- **NAME**: 명령어/함수의 이름과 한 줄 요약 설명
- **SYNOPSIS**: 명령어/함수의 사용 형식, 필요한 헤더 파일, 파라미터 종류 등을 보여주는 사용법 요약
- **DESCRIPTION**: 명령어/함수의 기능에 대한 상세한 설명
- **OPTIONS / PARAMETERS**: 함께 사용할 수 있는 옵션이나 각 파라미터의 의미
- **RETURN VALUE**: 함수가 성공 또는 실패했을 때 반환하는 값 (주로 시스템 호출이나 라이브러리 함수 페이지에 있음)
- **ERRORS**: 발생할 수 있는 오류의 종류와 원인
- **EXAMPLES**: 실제 사용 예제
- **SEE ALSO**: 함께 보면 좋은 관련 명령어/함수 목록
<br>

## 🎯 man 명령어 사용 예제  
ls 명령어의 설명서(manual)를 보는 명령어 예제
```
$ man ls
```

명령어 실행 결과
```
LS(1)                       General Commands Manual                      LS(1)

NAME
     ls – list directory contents

SYNOPSIS
     ls [-@ABCFGHILOPRSTUWabcdefghiklmnopqrstuvwxy1%,] [--color=when]
        [-D format] [file ...]

DESCRIPTION
     For each operand that names a file of a type other than directory, ls
     displays its name as well as any requested, associated information.  For
     each operand that names a file of type directory, ls displays the names
     of files contained within that directory, as well as any requested,
     associated information.

     If no operands are given, the contents of the current directory are
     displayed.  If more than one operand is given, non-directory operands are
     displayed first; directory and non-directory operands are sorted
     separately and in lexicographical order.

     The following options are available:

     -@      Display extended attribute keys and sizes in long (-l) output.

     -A      Include directory entries whose names begin with a dot (‘.’)
             except for . and ...  Automatically set for the super-user unless
             -I is specified.

... 
```
---
<br>

# 3️⃣ 시스템 도구

## 🎯 로그인/로그아웃 명령어
| 명령어 | 기능 | 예제 |
| :---: | :---: | :---: |
| telnet | 리눅스 시스템 접속 | telnet ***.co.kr |
| ssh | 리눅스 시스템 접속 | ssh ***.co.kr |
| exit | 리눅스 시스템 접속 해제 | exit ***.co.kr |
| logout | 리눅스 시스템 접속 해제 | logout ***.co.kr |
<br>

## 🎯 파일/디렉토리 명령어
| 명령어 | 기능 | 주요 옵션 | 예제 |
| :---: | :---: | :---: | :---: |
| pwd | 현 디렉터리 경로 cnf력 | - | pwd |
| ls | 디렉터리 내용 출력 | -a : 숨김 파일 출력 <br> -l 파일 상세 정보 출력 | ls -a/tmp <br> ls -l |
| cd | 디렉터리 이동 | - | cd /tmp <br> cd -r dir1 dir2 |
| cp | 파일, 디렉터리 복사 | -r : 디렉터리 복사 | cp a.txt b.txt <br> cp -r dir1 dir2 |
| mv | 파일, 디렉터리 변경, 이동 | - | mv a.txt b.txt <br> mv dir1 dir2 <br> mv a.txt dir1 |
| rm | 파일, 디렉터리 삭제 | -r : 디렉터리 삭제 | rm a.txt <br> rm -r dir1 |
| mkdir | 디렉터리 생성 | - | mkdir dir1 |
| cat | 파일 내용 출력 | - | cat a.txt |
| more | 화면 크기 단위로 파일 내용 출력 | - | more a.txt |
| chmod | 파일,디렉터리 접근 권한 변경 | - | chmod 755 a.exe |
| grep | 패턴 검색 | - | grep abcd a.txt |
<br>

## 🎯 프로세스/기타 명령어
| 명령어 | 기능 | 주요 옵션 | 예제 |
| :---: | :---: | :---: | :---: |
| ps | 실행중인 프로세스의 정보 출력 | -ef : 모든 프로세스의 상세 정보 출력 | ps <br> ps -ef <br> ps -ef | grep ftp |
| kill | 프로세스 강제 종료 | -g : 강제 종료 | kill 5000 <br> kill -9 5001 |
| su | 사용자 계정변경 | - : 변경할 사용자와 환경 초기화 파일 실행 | su <br> su - <br> su - han02 |
| whereis <br> which | 파일 위치 검색 | - | whereis ls <br> which telnet |
<br><br>

# 4️⃣ vi 편집기 활용하기

## 🎯 vi 편집기란?
vi 편집기는 **터미널이나 콘솔 같은 텍스트 기반 환경에서 사용하는 화면 편집기(Screen Editor)**이다. 1976년에 개발된 매우 오래된 편집기이지만, 오늘날 거의 모든 유닉스(Unix) 및 리눅스(Linux) 시스템에 기본적으로 포함되어 있어 여전히 널리 사용된다. 

'vim' (Vi IMproved)은 vi의 기능을 대폭 확장한 버전으로, 현재는 대부분의 시스템에서 vi를 실행하면 실제로는 vim이 실행되는 경우가 많다. 
<br>


## 🎯 vi 편집기 명령어
vi 편집기를 실행하는 명령어는 다음과 같다.
```
$ vi test.c
```
| 명령어 | 기능 | 
| :---: | :---: |
| i, a ,o ,O | 입력 모드 전환 |
| ESC | 명령 모드 전환 |
| j, k, h, l 또는 방향키 | 커서 이동 |
| r | 한 글자 수정 |
| u, U | 명령 취소 |
| cw | 단어 수정 |
| :%s/aaa/bbb/g | 검색해서 수정 |
| shif + D | 커서 이후 삭제 |
| p | 붙이기 |
| 3x, 5x 등등 | 글자 삭제 |
| :wq | 저장하고 종료 |
| :q | 저장없이 종료 |
| shft + J | 행 붙이기 |
| Ctrl + I | 화면 다시 표시 |
| :set nu | 행 번호 보이기 |
| :set nonu | 행 번호 없애기 |


# 5️⃣ 컴파일링
## 🎯 컴파일
컴파일이란 텍스트로 작성한 프로그램을 시스템이 이해할 수 있는 기계어로 변환하는 과정

컴파일 한다 = 보통 컴파일 과정과 라이브러리 링크 과정을 하나로 묶어서 수행하는 것
<br>

## 🎯 GCC
리눅스에서 컴파일을 하는 과정에서 가장 널리 사용되는 도구는 GCC이다.

GCC는 C, C++, Objective-C 등 다양한 프로그래밍 언어를 컴파일할 수 있는 컴파일러 모음이다.

명령어 
```
GCC : C언어를 컴파일할 때 사용하는 명령어
G++ : C++를 컴파일할 때 사용하는 명령어
```
<br>

### 🎯 GCC 명령어
- 형식 : `GCC [옵션] [파일명]`
- 옵션 :
     - -c : 오브젝트 파일(.o)만 생성
     - -o : 실행 파일명 = 지정한 이름으로 실행 파일을 생성, 기본 실행 파일명은 a.out
- 사용 예시 :
     ```
     $ gcc test.c
     $ gcc -c test.c
     $ gcc -o test test.c
     ```
<br>

### 🎯 리눅스 컴파일 과정
GCC를 이용한 컴파일은 내부적으로 네 가지 단계를 거쳐 진행됩니다.

1. 전처리 (Preprocessing)

     - 소스 코드에서 `#include`, `#define` 같은 전처리기 지시문을 처리합니다.

     - #include <stdio.h>는 `stdio.h` 파일의 내용을 가져와 코드에 삽입하고, 주석을 제거하는 등의 작업을 수행합니다.

     - 명령어: `gcc -E hello.c -o hello.i`

2. 컴파일 (Compilation)

     - 전처리가 끝난 C 코드를 어셈블리어로 변환합니다. 어셈블리어는 기계어와 일대일로 대응되는 저수준 언어입니다.

     - 명령어: `gcc -S hello.i -o hello.s`

3. 어셈블 (Assembly)

     - 어셈블리어를 실제 컴퓨터가 읽을 수 있는 기계어 코드(오브젝트 코드)로 변환합니다. 이 파일은 보통 .o 확장자를 가집니다.

     - 명령어: `gcc -c hello.s -o hello.o`

4. 링킹 (Linking)

      - 생성된 오브젝트 파일(hello.o)과 프로그램에 필요한 라이브러리 파일(예: printf 함수가 포함된 C 표준 라이브러리)을 연결하여 최종 실행 파일을 만듭니다.

     - 명령어: `gcc hello.o -o hello`

## 🎯 Makefile
### Makefile 이란?
- Makefile : 컴파일 명령, 소스 파일을 컴파일 하는 방법, 링크할 파일, 실행 파일명 등을 설정하는 파일
- make 명령 : Makefile을 읽고 이 파일에서 지정한대로 컴파일을 실행해 실행 파일을 생성
```
$ sudo apt install make
```

### 예제
실행할 디렉터리에서 Makefile, File1.c, File2.c를 생성한 후 4번 코드와 같이 실행하면 된다.

1. Makefile
     ```
     # Makefile

     CC = gcc
     CFLAGS=
     OBJS=File1.o test3.o
     LIBS=
     all:    add 

     add:    $(OBJS)
          $(CC) $(CFLAGS) -o add $(OBJS) $(LIBS)

     File1.o:        File1.c
          $(CC) $(CFLAGS) -c File1.c
     test3.o:        test3.c
          $(CC) $(CFLAGS) -c test3.c
     clean:
          rm -f $(OBJS) add 
     ```
2. File1.c
     ```
     // File1.c

     #include <stdlib.h>
     #include <stdio.h>
     #include <fcntl.h>

     // 외부 파일에 정의된 addnum() 함수를 사용함을 선언
     extern int addnum(int a, int b);

     int main() {
          int sum;

          sum = addnum(1, 5); 
          printf("Sum  = %d\n", sum);

          return(0);
     }
     ```
3. File2.c
     ```
     // File2.c

     int addnum(int a, int b) {

          int sum = 0;
          for (; a<=b; a++) sum += a;
          return sum;

     }
     ```
4. 실행
     ```
     $ ls
     Makefile  test2.c test3.c

     $ make
     gcc  -c test2.c
     gcc  -c test3.c
     gcc  -o add test2.o test3.o 

     $ ./add
     Sum  = 15
     ```
<br>

### **`make` 명령어의 작동 원리: 컴파일과 링크**

`make` 명령어는 **`Makefile`이라는 레시피(설명서)를 읽고 그대로 따라하는 요리사** 👨‍🍳라고 생각하시면 된다. 

`Makefile`에는 최종 프로그램(`add`)을 만들기 위해 어떤 재료(`test2.o`, `File2.o`)가 필요하고, 그 재료들은 또 어떤 원재료(`test2.c`, `File2.c`)로부터 만들어야 하는지가 순서대로 정의되어 있다.

사용자가 터미널에서 `make`를 입력하면 다음과 같은 일이 순서대로 일어납니다.
<br>

#### **1단계: 목표 설정**

`make`는 `Makefile`의 맨 위에 있는 목표(`all`)를 최종 목표로 삼습니다. 그런데 `all`을 만들기 위해서는 `add`가 필요하다고 되어 있네요. 따라서 최종 목표는 `add` 실행 파일을 만드는 것이 됩니다.
<br>

#### **2단계: 의존성 확인 및 개별 컴파일**

`make`는 `add`를 만들기 위해 무엇이 필요한지 확인합니다. 레시피에 `add: $(OBJS)` 즉, `add: File1.o File2.o`라고 적혀있으니, `File1.o`와 `File2.o` 파일이 필요하다는 것을 알게 됩니다.

- **`File1.o` 만들기**: `make`는 `File1.o`를 만드는 방법을 찾아봅니다. `Makefile`에 `File1.o: File1.c`라는 규칙이 있네요. 이 규칙에 따라 `gcc -c File1.c` 명령을 실행합니다.
    - `c` 옵션은 "컴파일만 하고, 실행 파일로 합치지는(링크) 말라"는 뜻입니다. 이 명령으로 `File1.c`는 기계어 코드 덩어리인 `File1.o` (오브젝트 파일)로 변환됩니다.

- **`File2.o` 만들기**: 위와 동일하게 `File2.o: File2.c` 규칙을 찾아 `gcc -c File2.c` 명령을 실행합니다. 이로써 `File2.o` 파일이 생성됩니다.

이 과정이 바로 터미널에 첫 두 줄로 나타난 것입니다.

```c
$ make
gcc  -c File1.c   # File1.o 생성
gcc  -c File2.c   # File2.o 생성
```
<br>

#### **3단계: 링크하여 최종 파일 생성**

이제 `add`를 만드는 데 필요한 재료인 `File1.o`와 `File2.o`가 모두 준비되었습니다. `make`는 드디어 `add`를 만드는 규칙을 실행합니다.

```c
add:    $(OBJS)
	$(CC) $(CFLAGS) -o add $(OBJS) $(LIBS) 
# 위 명령은 변수가 치환되어 아래처럼 실행됩니다.
# gcc -o add File1.o teFile2st3.o
```

이 명령은 **링크(Link)** 과정입니다. 각각의 기계어 코드 덩어리(`File1.o`, `File2.o`)를 하나로 합치고, `File1.c`에서 `extern`으로 선언만 했던 `addnum` 함수가 실제로는 `File2.o`에 있다는 것을 연결해 주어 완전한 하나의 실행 파일 `add`를 생성합니다.

### 기타 사항

- 만약 컴파일 한 이후 다시 컴파일을 하려고 하면 실행이 안된다. \
→ “이미 컴파일 했는데???” 라고 서버가 생각하기 때문
- 따라서 다시 컴파일 하려면 `touch` 명령어를 실행해야한다.
     ```
     $ touch test2.c test3.c
     ```