
# 환경 변수

## 1️⃣ 환경 변수의 활용



### 🎯 환경 변수의 이해
- 환경변수는 `환경변수명=값`의 형태로 구성
- 환경변수명은 관례적으로 대문자
``` 
$ env 
```



### 🎯 전역 변수 사용 : environ
```
#include <unistd.h>
extern char **environ;
```
- environ : 환경변수 전체에 대한 포인터

#### [ 2. 예시 코드 ]
```
// ex_1.c

#include <unistd.h>
#include <stdio.h>

extern char **environ;

int main() {
    char **env;

    env = environ;
    while (*env) {
        printf("%s\n", *env);
        env++;
    }
}
```



### 🎯 main() 함수 인자 활용

#### [ 1. 설명 ]
```
int main(int argc, char **argv, char **envp)
```
- environ()과 같은 사용법

#### [2. 코드 예시 ]
```
// ex_2.c

#include <stdio.h>

int main(int argc, char **argv, char **envp) {
     char **env;

     env = envp;
     while (*env) {
         printf("%s\n", *env);
         env++;
     }
}
```



### 🎯 환경 변수 검색 : getenv()

#### [ 1. 설명 ]
```
#include <stdlib.h>

char *getnev(const char *name);
```
- name : 환경 변수명
- shell 사용시 `echo`도 사용 방법이 될 수 있다! 

#### [ 2. 코드 예시 ]
```
// ex_3.c

#include <stdlib.h>
#include <stdio.h>

int main() {
    char *val;

    val = getenv("SHELL");
    if (val == NULL)
        printf("SHELL not defined\n");
    else
        printf("SHELL = %s\n", val);
}
```

### 🎯 환경 변수 설정 : putenv()

#### [ 1. 설명 ]
```
#include <stdlib.h>

int putenv(char *string);
```
- string : 설정할 환경 변수와 값으로 구성한 문자열
- 해당 프로세스만 변경되고 부모 프로세스의 환경변수는 설정되지 않는다!

#### [ 2. 코드 예시 ]
```
// ex_4.c

#include <stdlib.h>
#include <stdio.h>

int main() {
    char *val;

    val = getenv("TERM");
    if (val == NULL)
        printf("TERM not defined\n");
    else
        printf("1. TERM = %s\n", val);

    putenv("TERM=vt100");

    val = getenv("TERM");
    printf("2. TERM = %s\n", val);
}
```

### 🎯 환경 변수 설정 : setenv()

#### [ 1. 설명 ]
```
#include <stdlib.h>

int setnev(const char *name, const char *value, int overwirte);
```
- name : 환경 변수명
- value : 환경 변수값
- overwirte : 덮어쓰기 여부
    - overwirte == 0 : 덮어쓰기 O
    - overwirte != 0 : 덮어쓰기 X

#### [ 2. 코드 예시 ]
```
// ex_5.c

#include <stdlib.h>
#include <stdio.h>

int main() {
    char *val;

    val = getenv("TERM");
    if (val == NULL)
        printf("TERM not defined\n");
    else
        printf("1. TERM = %s\n", val);

    setenv("TERM","vt100", 0);
    val = getenv("TERM");
    printf("2. TERM = %s\n", val);

    setenv("TERM","vt100", 1);
    val = getenv("TERM");
    printf("3. TERM = %s\n", val);
}
```

### 🎯 환경 변수 삭제 : unseteenv()

#### [ 1. 설명 ]
```
#include <stdlib.h>

int unsetenv(const char *name);
```
- name : 환경변수명
- name에 지정한 환경변수를 삭제

---

# 호환성 모드

## 1️⃣ 개요



### 🎯 프로세스 생성과 종료

#### [ 1. 프로세스 생성 ]
프로세스를 생성하는 함수로는 system(), fork(), vfork() 등이 있음
```
int system(const char *command);    // 프로그램 실행
pid_t fork(void);                   // 프로세스 생성
pid_t vfork(void);                  // 프로세스 생성
```

#### [ 2. 프로세스 종료 ]
리눅스에서는 프로세스 종료시 종료 상태를 저장함

자식 프로세스는 부모 프로세스에게 어떻게 종료되었는지를 알림

```
// 프로세스 종료
void exit(int status);
void _exit(int status);     

// 종료시 수행할 작업 지정
int atexit(void (*function)(void))      
int on_exit(void (*function)(int, void *), void *arg);
```



### 🎯 프로세스 동기화 : wait()

**[ 예시 코드 ]**
```
#include <sy/types.h>
#include <sys/wait.h>

pid_t wait(int *wstatus)
```
- wstatus : 상태 정보를 저장할 주소

**[ wait() 함수의 정보 ]**
- 자식 프로세스가 종료할 때까지 부모 프로세스를 기다리게함
- 자식 프로세스의 종료 상태는 wstatus에 지정한 주소에 저장 (NULL 가능)
- 부모 프로세스가 wait() 함수를 호출하기 전에 자식 프로세스 종료시 즉시 리턴
    - 반환값 : 자식 프로세스 PID (없을 시 -1)

**[ wait() 코드 예시 ]**
```
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    int status;
    pid_t pid;

    switch (pid = fork()) {
        case -1 : /* fork failed */
            perror("fork");
            exit(1);
            break;
        case 0 : /* child process */
            printf("--> Child Process\n");
            exit(2);
            break;
        default : /* parent process */
            while (wait(&status) != pid)
                continue;
            printf("--> Parent process\n");
            printf("Status: %d, %x\n", status, status);
            printf("Child process Exit Status:%d\n", status >> 8);
            break;
    }
}
```



### 🎯 프로세스 동기화 : waitpid()

**[ 예시 코드 ]**
```
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *wstatus, int options)
```
- pid : 종료를 기다리는 pid
    - pid < -1 : 동일 PGD에 속한 자식 프로세스 중 임의의 자식 프로세스의 상태값을 요청
    - pid == -1 : 임의의 자식 프로세스의 상태값 요청
    - pid == 0 : 같은 PGID에 속한 임의의 프로세스의 상태값을 요청
    - pid > 0 : 지정한 pid에 해당하는 프로세스 상태값을 요청
- status : 종료 상태값을 저장할 주소
- options : wait() 함수의 리턴 조건

**[ waitpid() 함수 정보 ]**
- 자식 프로세스 종료의 status에 저장
- options의 조건에 따라 리턴

**[ waitpid()의 예시 ]**
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>

main() {

	int status;
	pid_t pid;
#ifdef TIMES
	struct timeval stime,etime;
	int time_result;
#endif
	if ((pid = fork()) < 0) {
		perror("fork");
		exit(1);
	}
#ifdef TIMES
	gettimeofday(&stime, NULL);
#endif

	if (pid == 0) {
		printf("--> Child process\n");
		sleep(3);
		exit(3);
	}
#ifdef TIMES
	gettimeofday(&etime, NULL);
	time_result = etime.tv_usec - stime.tv_usec;
	printf("TIMES == %ld %ld %ld\n", etime.tv_usec, stime.tv_usec, time_result);
#endif
	printf("--> Parent process\n");

	while (waitpid(pid, &status, WNOHANG) == 0) {
		printf("Parent still wait..\n");
		sleep(1);
	}
	printf("Child Exit Status : %d\n", status>>8);

}
```





## 2️⃣ 프로세스 생성

### 🎯 프로그램 실행 : system()

### 🎯 프로세스 생성 : fork() 
#### [ 1. 설명 ]

#### [ 2. 코드 예시 ]

### 🎯 프로세스 종료 : exit()


## 3️⃣ exec 함수군 활용
### 🎯 exec 함수군의 형태
```
#include <unistd.h>

int execl(const char *pathname, const char *arg, /*(char *)NULL*/);

int execlp(const char *file, const char *arg, /*(char *)NULL*/);

int execle(const char *pathname, const char *arg, /*(char *)NULL, char *const envp[] */);    // 환경 변수 설정 가능

int execv(const char *pathname, const char *argv[]);

int execvp(const char *file, const char *arg);

int execvpe(const char *file, const char *arg, /*(char *)NULL*/);
```

```
ex_6.c
```






fork()와 execlp() 이용하기

## 4️⃣ 프로세스 동기화
### 🎯 좀비 프로세스

### 🎯 프로세스 동기화 : wait()
- 자식 프로세스가 종료할 때까지 부모 프로세스 대기 -> 좀비 프로세스 방지