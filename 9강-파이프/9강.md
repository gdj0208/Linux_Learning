
# 파이프

## 1️⃣ 파이프

### 🎯 파이프란?
- 두 프로세스 사이에서 한 방향으로 통신할 수 있도록 지원하는 것
- Shell에서 `|` 가 파이프를 의미
```shell
$ cat test.c | more
```
- cat test.c의 표준 출력을 다음 명령인 more의 표준 입력으로 사용

(18)
- write()시 파이프에 충분한 공간이 있으면 파이프 저장
1. 쓰기 전용 파일 기술자를 닫은 경우 :
2. 읽기 저뇽 파일 기술자를 닫은 경우 : 
    - 자료 읽기를 위해 해당 파이프를 개방햔 타 프로세스 존재 : Ok
    - SIGPIPE 시그널 (오류)



### 🎯 이름 없는 파이프 : pipe
```c
FILE *popen(const char *command, const char *type); // 고수준 시스템콜
int pclose(FILE *stream);   // 저수준 시스템 콜

int pipe(int pipefd[2]);
```
- 부모-자식 프로세스간 통신
- 단 방향 통신 : '부모->자식' 또는 '자식->부모' 한 방향으로만 통신



### 🎯 이름 있는 파이프 : FIFO
```c
int mknod(const char *pathname, mode_t mode, dev_t dev);
int mkfifo(const char *pathname, mode_t mode);
```
- 부모-자식 프로세스 관계가 아닌 독립적인 프로세스들의 파이프 사용 가능






## 2️⃣ 이름 없는 파이프

### 🎯 파이프 만들기 : popen()

**[ 코드 ]**
```c
FILE *popen(const char *command, const char *type);
```
- command : 셸 명령
- type : "r", "w"

**[ 특징 ]**
- 다른 프로세스와 통신하기 위한 파이프 설정
- 내부적으로 fork()를 실행하여 자식 프로세스 형성 -> 자식 프로세스 command에 exec() 실행

**[ 예제 ]**
```c
// ex_2.c

#include <stdlib.h>
#include <stdio.h>

int main( ) {
    FILE *fp;
    char buf[256];

    fp = popen("date", "r");
    if (fp == NULL) {
       fprintf(stderr, "popen failed\n");
       exit(1);
    }

    if (fgets(buf, sizeof(buf), fp) == NULL) {
        fprintf(stderr, "No data from pipe!\n");
        exit(1);
    }

    printf("line : %s\n", buf);
    pclose(fp);
}

// 실행 결과 : 
// line : 2025. 10. 29. (수) 21:23:19 KST
```



### 🎯 파이프 닫기 : pclose()

**[ 코드 ]**
```c
int pclose(FILE *stream);
```

**[ 특징 ]**
- 파일 입출력 함수처럼 인자로 지정한 파이프를 닫음
- 관련된 waitpid() 수행 -> 자식 프로세스들이 종료하길 기다렸다가 리턴

**[ 예제 ]**
```c
// ex_1.c

#include <stdlib.h>
#include <stdio.h>

int main( ) {
    FILE *fp;
    int a;

    fp = popen("wc -l", "w");
    if (fp == NULL) {
        fprintf(stderr, "popen failed\n");
        exit(1);
    }

    for (a = 0; a < 100; a++)
        fprintf(fp, "test line\n");

    pclose(fp);
}

// 실행 결과 : 100
```



### 🎯 파이프 만들기 : pipe()

**[ 설명 ]**
```c
int pipe(int pipefid[2]);
```
- pipefd[2] : 파이프로 사용할 파일 기술자 (2개)
    - pipefd[0] : 읽기 전용
    - pipefd[1] : 쓰기 전용

**[ 특징 ]**
- 파일기술자 2개를 받아 저장

**[ pipe 통신 과정 ]**
1. pipe()를 호출해 파이프에 사용할 파일 기술자를 얻음
![alt text](image.png)

    ```c
    //ex_3.c

    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>

    #define MSGSIZE		16

    char *msg1 = "hello, world #1";
    char *msg2 = "hello, world #2";
    char *msg3 = "hello, world #3";

    main() {

        char inbuf[MSGSIZE];
        int p[2], j;

        if (pipe(p) == -1) { perror("pipe call"); exit(1); }

        write(p[1], msg1, MSGSIZE);
        write(p[1], msg2, MSGSIZE);
        write(p[1], msg3, MSGSIZE);

        for (j=0; j<3; j++) { 
            read(p[0], inbuf, MSGSIZE);
            printf("%s\n", inbuf);
        }

        exit(0);
    }
    ```
    - 위 코드에서는 p[1]의 write를 파이프를 통해 p[0]가 읽고 차후 p[0]에서 문자열을 출력

2. fork() 함수를 수행해 지식 프로세스를 생성 
![alt text](image-1.png)

    ```c
    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>

    #define MSGSIZE		16

    char *msg1 = "hello, world #1";
    char *msg2 = "hello, world #2";
    char *msg3 = "hello, world #3";

    main() {

        char inbuf[MSGSIZE];
        int p[2], j;
        pid_t pid;

        if (pipe(p) == -1) { perror("pipe call"); exit(1); }

        switch (pid = fork()) {
        case -1:
            perror("fork call");
            exit(2);
        case 0:
            write(p[1], msg1, MSGSIZE);
            write(p[1], msg2, MSGSIZE);
            write(p[1], msg3, MSGSIZE);
            break;
        default:
            for (j=0; j<3; j++) {
                read(p[0], inbuf, MSGSIZE);
                printf("%s\n", inbuf);
            }
            wait(NULL);
        }

        exit(0);
    }
    ```
    - 부모 프로세스 내 p[0], p[1] 보유
    - 자식 프로세스 내 p[0], p[1] 보유
    - 파이프를 통해 부모 p[1]->자식 p[0], 자식 p[1]->부모 p[0]

3. 파이프는 단방향 통신이므로 방향을 결정


**[ pipe() 예시 코드들 ]**
- pipe() 함수로 명령 실행하기
```c
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main( ) {
    int fd[2];
    pid_t pid;
    char buf[257];
    int len, status;

    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }

    switch (pid = fork( )) {
    case -1 :
        perror("fork");
        exit(1);
        break;
    case 0 : /* child */
        close(fd[1]);
        write(1, "Child Process:", 15);
        len = read(fd[0], buf, 256);
        write(1, buf, len);
        close(fd[0]);
        break;
    default :
        close(fd[0]);
        write(fd[1], "Test Message\n", 14);
        close(fd[1]);
        waitpid(pid, &status, 0);
        break;
    }
}
```

- pipe() 함수로 명령 실행하기
```c
// ex_6.c

#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(void) {
    int fd[2];
    pid_t pid;

    if (pipe(fd) == -1) {
        perror("pipe");
        exit(1);
    }

    switch (pid = fork()) {
        case -1 :
            perror("fork");
            exit(1);
            break;
        case 0 : /* child */
            close(fd[1]);
            if (fd[0] != 0) {
                dup2(fd[0], 0);
                close(fd[0]);
            }
            execlp("grep", "grep", "ssh", (char *)NULL);
            exit(1);
            break;
        default :
            close(fd[0]);
            if (fd[1] != 1) {
                dup2(fd[1], 1);
                close(fd[1]);
            }
            execlp("ps", "ps", "-ef", (char *)NULL);
            wait(NULL);
            break;
    }

    return 0;
}
```

- 양방향 통신하기
```c
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main( ) {
    int fd1[2], fd2[2];
    pid_t pid;
    char buf[257];
    int len, status;

    if (pipe(fd1) == -1) {
        perror("pipe");
        exit(1);
    }

    if (pipe(fd2) == -1) {
        perror("pipe");
        exit(1);
    }

    switch (pid = fork( )) {
        case -1 :
            perror("fork");
            exit(1);
            break;
        case 0 : /* child */
            close(fd1[1]);
            close(fd2[0]);
            len = read(fd1[0], buf, 256);
            write(1, "Child Process:", 15);
            write(1, buf, len);

            strcpy(buf, "Good\n");
            write(fd2[1], buf, strlen(buf));
            break;
        default :
            close(fd1[0]);
            close(fd2[1]);
            write(fd1[1], "Hello\n", 6);

            len = read(fd2[0], buf, 256);
            write(1, "Parent Process:", 15);
            write(1, buf, len);
            waitpid(pid, &status, 0);
            break;
    }
}

/*
실행 결과 : 
Child Process:Hello
Parent Process:Good
*/
```